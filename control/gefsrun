#!/bin/ksh
#
# set up and start a parallel GEFS job
#
echo
echo `date` $0 $*                                                                   begin
echo
echo
echo `date` $0 $*                                                         check arguments
echo

goodargs=yes
nextflag=no
tseqflag=no
tcdsflag=no
tjobflag=no
testflag=yes
testflag=no
joblistflag=no
whenrun=neither
NDATE=${NDATE:-/gpfs/dell1/nco/ops/nwprod/prod_util.v1.1.1/exec/ips/ndate}
# special section for testing only
if (( 0 == 0 )); then
  echo
fi
if (( 0 == 1 )); then
  echo
  echo TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST
  tcdsflag=yes
  testflag=yes
  echo tcdsflag=$tcdsflag
  echo testflag=$testflag
  echo TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST
  echo
fi
if (( $# == 3 )); then
  a3=$3
  case $a3 in
    (next)
      nextflag=yes
    ;;
    (nextbefore)
      nextflag=yes
      whenrun=before
    ;;
    (nextafter)
      nextflag=yes
      whenrun=after
    ;;
    (tseq)
      tseqflag=yes
      testflag=yes
    ;;
    (tseqnext)
      nextflag=yes
      tseqflag=yes
      testflag=yes
    ;;
    (tcds)
      tcdsflag=yes
      testflag=yes
    ;;
    (tcdsnext)
      nextflag=yes
      tcdsflag=yes
      testflag=yes
    ;;
    (tjob)
      tjobflag=yes
      testflag=yes
    ;;
    (tjobnext)
      nextflag=yes
      tjobflag=yes
      testflag=yes
    ;;
    (*)
      echo a3=$a3 NOT RECOGNIZED
      goodargs=no
    ;;
  esac
 if [[ $testflag = yes ]]; then
    sleep 2
  fi
fi
cyct=99
typeset -RZ3 jjjb
typeset -RZ3 jjjc

if [[ $goodargs = yes ]]; then
  goodargs=no
  if (( $# > 0 )); then
    if [[ $1 = joblist ]]; then
      joblistflag=yes
      testflag=yes
      echo `date` since a list of job number has been requested, dummy dates will be used
      yyyymmddccjjjb=2003040512000
      yyyymmddccb=2003040512
      cyct=00
      jjjb=000
      yyyymmddccjjje=2001020312000
      yyyymmddcce=2003040512
      jjje=000
      goodargs=yes
    elif [[ $nextflag = yes ]]; then
      yyyymmddccjjjc=$1
      yyyymmddccc=`echo $yyyymmddccjjjc|cut -c1-10`
      cyct=`echo $yyyymmddccc|cut -c9-10`
      jjjc=`echo $yyyymmddccjjjc|cut -c11-13`
      yyyymmddccjjje=$2
      yyyymmddcce=`echo $yyyymmddccjjje|cut -c1-10`
      jjje=`echo $yyyymmddccjjje|cut -c11-13`
      echo called by one job to set up the next
      echo yyyymmddccjjjc=$yyyymmddccjjjc
      echo yyyymmddccc=$yyyymmddccc
      echo jjjc=$jjjc
      goodargs=yes
    else
      yyyymmddccjjjb=$1
      yyyymmddccb=`echo $yyyymmddccjjjb|cut -c1-10`
      cyct=`echo $yyyymmddccb|cut -c9-10`
      jjjb=`echo $yyyymmddccjjjb|cut -c11-13`
      if (( $# > 1 )); then
	yyyymmddccjjje=$2
      else
	yyyymmddccjjje=$1
      fi
      yyyymmddcce=`echo $yyyymmddccjjje|cut -c1-10`
      jjje=`echo $yyyymmddccjjje|cut -c11-13`
      echo called by the number of the job to start
      echo yyyymmddccjjjb=$yyyymmddccjjjb
      echo yyyymmddccb=$yyyymmddccb
      echo jjjb=$jjjb
      goodargs=yes
    fi
    echo cyct=$cyct
    echo yyyymmddccjjje=$yyyymmddccjjje
    echo yyyymmddcce=$yyyymmddcce
    echo jjje=$jjje
  fi
fi
echo goodargs=$goodargs 
echo nextflag=$nextflag
echo tseqflag=$tseqflag
echo tcdsflag=$tcdsflag
echo tjobflag=$tjobflag
echo testflag=$testflag
if [[ $goodargs != yes ]]; then
  echo
  echo 'usage:' $0 ' yyyymmddccjjj [yyyymmddccjjj] [next[tseq|tcds|tjob]]'
  echo
  echo 1st argument is dtg and job number to start
  echo 2nd argument is dtg and job number to end if different from start
  echo
  echo next = start with job after jjj, for use by batch jobs
  echo
  echo   options to test changes to job order and logic
  echo tseq = test this script for each job in sequence
  echo tcds = test generate but do not submit job cards
  echo tjob = test submit job but do not run job script
  echo
  echo 'usage:' $0 joblist
  echo "    " to display a list of job numbers
  echo
  echo 'usage:' $0
  echo "    " to display this message
  echo
  echo `date` $0 $* ABORT EXIT 2
  echo
  exit 2
fi


echo
echo `date` $0 $*                                                    create log and expid
echo
 
nldir=`pwd`
nlddir=`dirname $nldir`
nldbdir=`basename $nlddir`
nldddir=`dirname $nlddir`
nlddbdir=`basename $nldddir`
nlddddir=`dirname $nldddir`
nldddbdir=`basename $nlddddir`
echo nldir=$nldir 
echo nlddir=$nlddir 
echo nldbdir=$nldbdir 
echo nldddir=$nldddir
echo nlddbdir=$nlddbdir

callstring=`echo $*|tr " " "."`.`basename $0`
envir=`echo $nlddbdir|cut -c3-`
echo callstring=$callstring envir=$envir 

expid=$nldddbdir
id=`echo $expid|cut -c3-4`
echo expid=$expid id=$id

#DHOU, 01/03/2013 add this block to generate the gefsmachine name related variables
  machl=`uname -n | cut -c1`
  case $machl in
   (c) gefsmachine=ccs ;;
   (s) gefsmachine=ccs ;;
   (r) gefsmachine=zeus ;;
   (f) gefsmachine=zeus ;;
   (t) gefsmachine=wcoss ;;
   (g) gefsmachine=wcoss ;;
   (v) gefsmachine=dell ;;
   (m) gefsmachine=dell ;;
  esac 
  if [[ $machl = r ]]; then                       
       machl=f
  fi
  case $gefsmachine in
   (ccs) gefsmpexec= ;;
   (zeus) gefsmpexec="mpiexec_mpt -np \$total_tasks" ;;
   (wcoss) gefsmpexec="mpirun.lsf" ;;
   (dell) gefsmpexec="mpirun" ;;
  esac

case $gefsmachine in
  (dell)
    PTMP=/gpfs/dell3/ptmp
    STMP=/gpfs/dell3/ptmp
    COREPERNODE=28
  ;;
  (*)
    PTMP=/ptmpd2
    STMP=/ptmpd2
    COREPERNODE=16 
  ;;
esac


export gefsmachine
echo gefsmachine=$gefsmachine
export gefsmpexec
echo gefsmpexec=$gefsmpexec

mach=`uname -n`
dtg=`date +%Y%m%d%H%M%S`
pid=$$
echo dtg=$dtg mach=$mach pid=$pid

echo
echo `date` $0 $*                                           prepare to log this execution
echo

lname=$callstring.$expid.$dtg.$mach.$pid
if [[ $LOGNAME = glopara ]]; then
  # ldir=$PTMP/$LOGNAME/para_gefs/temp.gefs.run
  ldir=$PTMP/$LOGNAME/para_gefs/o/$expid/runlog
else
  # ldir=$PTMP/$LOGNAME/temp.gefs.run
  ldir=$PTMP/$LOGNAME/o/$expid/runlog
#The next two lines for Zeus
  if [[ $gefsmachine = zeus ]]; then                       
  ZPTM=/scratch2/portfolios/NCEPDEV
  ldir=$ZPTM/ptmp/$LOGNAME/o/$expid/runlog
  fi
fi
echo ldir=$ldir lname=$lname
mkdir -p $ldir
rc=$?
if (( rc != 0 )); then
  echo mkdir -p $ldir FAILED rc=$rc
  echo 
  echo `date` $0 $* ABORT EXIT $rc
  echo
  exit $rc
fi

(
echo
echo `date` $0 $*                                                               log begin
echo

#########################################################################################
echo
echo `date`     TO FIND JOB SETTINGS TO CHANGE, SEARCH FOR setup OR ONE OF THESE STRINGS
echo
grep setup $0 | grep -v 'TO FIND JOB SETTINGS TO CHANGE'
echo
#########################################################################################

echo
echo `date` $0                                         variables set before logging began
echo

echo yyyymmddccjjjc=$yyyymmddccjjjc
echo yyyymmddccc=$yyyymmddccc
echo jjjc=$jjjc
echo
echo yyyymmddccjjjb=$yyyymmddccjjjb
echo yyyymmddccb=$yyyymmddccb
echo jjjb=$jjjb
echo
echo yyyymmddccjjje=$yyyymmddccjjje
echo yyyymmddcce=$yyyymmddcce
echo jjje=$jjje
echo
echo goodargs=$goodargs 
echo nextflag=$nextflag
echo tseqflag=$tseqflag
echo tcdsflag=$tcdsflag
echo tjobflag=$tjobflag
echo testflag=$testflag
echo
echo nldir=$nldir 
echo nlddir=$nlddir 
echo nldbdir=$nldbdir 
echo nldddir=$nldddir
echo nlddbdir=$nlddbdir
echo callstring=$callstring envir=$envir 
echo expid=$expid id=$id
echo
echo dtg=$dtg mach=$mach pid=$pid
echo ldir=$ldir lname=$lname


echo
echo `date` $0 $*                                            set directory tree locations
echo

cwd=`dirname $0`
echo cwd=$cwd

. $cwd/setbase

echo END of SETBASE !!!!!!!

echo basesource=$basesource
echo baseoutput=$baseoutput
echo baseinitarch=$baseinitarch
echo basetmp=$basetmp

if [[ $gefsmachine = wcoss ]]; then

jobdir=$basesource/nw$envir/gefs_legacy.${gefs_legacy_ver}/jobs
echo jobdir=$jobdir

controldir=$basesource/nw$envir/gefs_legacy.${gefs_legacy_ver}/control
echo controldir=$controldir

parmdir=$basesource/nw$envir/gefs_legacy.${gefs_legacy_ver}/parm
echo parmdir=$parmdir

fi

if [[ $gefsmachine = dell ]]; then

gefs_legacy_ver=v10.5.1
jobdir=$basesource/nw$envir/gefs_legacy.${gefs_legacy_ver}/jobs
echo jobdir=$jobdir

controldir=$basesource/nw$envir/gefs_legacy.${gefs_legacy_ver}/control
echo controldir=$controldir

parmdir=$basesource/nw$envir/gefs_legacy.${gefs_legacy_ver}/parm
echo parmdir=$parmdir

fi

echo
echo `date` $0 $*                                                            define parms
echo

NET=gens

#. $cwd/../parm/gefs.parm
. $parmdir/gefs.parm

(( npert = npair * 2 ))
echo npert=$npert

echo RUN_CONCURRENT=$RUN_CONCURRENT

#########################################################################################
echo
echo `date`                         setup forecast length and number of forecast segments
echo
#########################################################################################

# this case statement is duplicated in the parm file, but does not work here or
# there if the variable cyc is not defined yet

# cyct is used because cyc has not been calculated yet,
# since it depends on the calculation of the next job number
# if 000 and 999 mark the beginning and the end of each cycle, 
# this does not cause a problem
echo fhmax=$fhmax
echo cyct=$cyct


case $cyct in
  (00) fhmax=$fhmax00 ;;
  (06) fhmax=$fhmax06 ;;
  (12) fhmax=$fhmax12 ;;
  (18) fhmax=$fhmax18 ;;
  (*) 
    echo
    echo UNDEFINED CYCLE cyct=$cyct
    echo
    echo `date` $0 $* ABORT EXIT 6
    echo
    exit 6
  ;;
esac

echo fhmax=$fhmax
export fhmax

#ZEUSTEST
#export yyyymmddcc=$yyyymmddccb
#export envir=$envir
#  $basesource/nwdev/control/control.r000
#exit
#ZEUSTEST

# set the number of forecast segments that will be run

if (( fhmax > fhmaxh )); then
  fcst_segments=2
else
  fcst_segments=1
fi
echo fcst_segments=$fcst_segments

echo
echo `date` env sort before
echo

env | sort

echo
echo `date` env sort after
echo

#########################################################################################
echo
echo `date`                                                             setup job numbers
echo
#########################################################################################
echo
echo `date`                      insert archive and cleanup jobs between jobs 900 and 999
echo
#########################################################################################

#########################################################################################
# note that in this section, the numbers   00, 06, 12, and 18 
# are offsets from the current cycle rather than actual cycles
#  00 = for the current cycle
#  06 = for the cycle to run 6 hours later
#  12 = for the cycle to run 12 hours later
#  18 = for the cycle to run 18 hours later
# when the job number is interpreted, the variable cyc_os
# contains the value of this offset for the job to be submitted

npertmax=28
if (( npert > npertmax )); then
  echo  too many perturbations for this numbering scheme npert=$npert npertmax=$npertmax
  echo
  echo `date` $0 $* ABORT EXIT 3
  echo
  exit 3
fi

jjjf00=100
jjjf00l=300
jjjf06=600
jjjf12=700
jjjf18=800

(( jjjpo = 1 ))
(( jjjro = 100 ))
(( jjjog = 92 ))
(( jjjos = 94 ))
(( jjjoo = 95 ))
(( jjjot = 96 ))
(( jjjoa = 97 ))
(( jjjoc = 99 ))

(( jjjpe = jjjpo + npert * 4 + 2 ))
(( jjjpec = jjjpo + npert * 4 - 2 ))

(( jjjre = jjjro + npert ))

typeset -RZ3 jjjg00=$(( jjjog ))

typeset -RZ3 jjjp00=$(( jjjf00 + jjjpo ))
typeset -RZ3 jjjp00l=$(( jjjf00l + jjjpo ))
typeset -RZ3 jjjp06=$(( jjjf06 + jjjpo ))
typeset -RZ3 jjjp12=$(( jjjf12 + jjjpo ))
typeset -RZ3 jjjp18=$(( jjjf18 + jjjpo ))

typeset -RZ3 jjje00=$(( jjjf00 + jjjpe ))
typeset -RZ3 jjje00l=$(( jjjf00l + jjjpe ))
typeset -RZ3 jjje06=$(( jjjf06 + jjjpec ))
typeset -RZ3 jjje12=$(( jjjf12 + jjjpec ))
typeset -RZ3 jjje18=$(( jjjf18 + jjjpec ))

typeset -RZ3 jjjr00=$(( jjjf00 + jjjro ))
typeset -RZ3 jjjz00=$(( jjjf00 + jjjre ))

typeset -RZ3 jjjs00=$(( jjjf00 + jjjos ))
typeset -RZ3 jjjs00l=$(( jjjf00l + jjjos ))
typeset -RZ3 jjjo00=$(( jjjf00l + jjjoo ))

typeset -RZ3 jjjt00=$(( jjjf00l + jjjot ))
typeset -RZ3 jjjt06=$(( jjjf06 + jjjot ))
typeset -RZ3 jjjt12=$(( jjjf12 + jjjot ))
typeset -RZ3 jjjt18=$(( jjjf18 + jjjot ))

typeset -RZ3 jjja00=$(( jjjf00l + jjjoa ))
typeset -RZ3 jjja01=$(( jjja00 + 1 ))

typeset -RZ3 jjjc18=$(( jjjf18 + jjjoc ))

echo
echo job number offsets
echo
echo jjjpo=$jjjpo
echo jjjpe=$jjjpe
echo jjjpec=$jjjpec
echo
echo jjjro=$jjjro
echo jjjre=$jjjre
echo
echo jjjog=$jjjog
echo jjjos=$jjjos
echo jjjoo=$jjjoo
echo jjjot=$jjjot
echo jjjoa=$jjjoa
echo jjjoc=$jjjoc
echo
echo job numbers
echo
echo jjjf00=$jjjf00
echo jjjp00=$jjjp00
echo jjje00=$jjje00
echo jjjg00=$jjjg00
echo jjjs00=$jjjs00
echo jjjr00=$jjjr00
echo jjjz00=$jjjz00
echo jjjf00l=$jjjf00l
echo jjjp00l=$jjjp00l
echo jjje00l=$jjje00l
echo jjjs00l=$jjjs00l
echo jjjo00=$jjjo00
echo jjjt00=$jjjt00
echo jjja00=$jjja00
echo
echo jjjf06=$jjjf06
echo jjjp06=$jjjp06
echo jjje06=$jjje06
echo jjjt06=$jjjt06
echo
echo jjjf12=$jjjf12
echo jjjp12=$jjjp12
echo jjje12=$jjje12
echo jjjt12=$jjjt12
echo
echo jjjf18=$jjjf18
echo jjjp18=$jjjp18
echo jjje18=$jjje18
echo jjjt18=$jjjt18
echo jjjc18=$jjjc18
echo

echo "           " job number table
echo
echo "   " job numbers depend on gefs.parm settings 
echo "   " and on settings within this script $0
echo
echo 000 first job of cycle
echo
echo 012 init separate job
echo 013 init et job
echo 014 init combine job
echo
echo "       " jobs for this cycle
echo
echo "   " forecast, copy, post and prdgen jobs $jjjf00 to $jjje00
typeset -RZ3 jjj=$jjjf00
typeset -RZ2 pp=00
while (( jjj < jjje00 ))
do
  (( pp = pp + 1 ))
  if (( pp > npert )); then
    pert=c00
  else
    pert=p$pp
  fi
  if [[ $RUN_CONCURRENT = no ]]; then
    echo $jjj forecast job for $pert
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for $pert
  elif (( pp == 1 )); then
    echo $jjj forecast job for all perturbations
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for all perturbations
  else
    (( jjj = jjj + 1 ))
  fi
  (( jjj = jjj + 1 ))
  echo $jjj post job for $pert
  (( jjj = jjj + 1 ))
  echo $jjj prdgen job for $pert
  (( jjj = jjj + 1 ))
done
echo
echo $jjjg00 gefs gfs job
echo $jjjs00 ensstat job
echo
echo "   " chgres jobs $jjjr00 to $jjjz00
typeset -RZ3 jjj=$jjjr00
typeset -RZ2 pp=00
pert=c$pp
while (( jjj <= jjjz00 ))
do
  echo $jjj chgres job for $pert
  (( jjj = jjj + 1 ))
  (( pp = pp + 1 ))
  pert=p$pp
done
echo
echo "   " low resolution forecast, copy, post and prdgen jobs $jjjf00l to $jjje00l
typeset -RZ3 jjj=$jjjf00l
typeset -RZ2 pp=00
while (( jjj < jjje00l ))
do
  (( pp = pp + 1 ))
  if (( pp > npert )); then
    pert=c00
  else
    pert=p$pp
  fi
  if [[ $RUN_CONCURRENT = no ]]; then
    echo $jjj low resolution forecast job for $pert
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for $pert
  elif (( pp == 1 )); then
    echo $jjj low resolution forecast job for all perturbations
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for all perturbations
  else
    (( jjj = jjj + 1 ))
  fi
  (( jjj = jjj + 1 ))
  echo $jjj low resolution post job for $pert
  (( jjj = jjj + 1 ))
  echo $jjj low resolution prdgen job for $pert
  (( jjj = jjj + 1 ))
done
echo
echo $jjjs00l low resolution ensstat job
echo
echo $jjjo00 enspost job
echo $jjjt00 tracking job
echo $jjja00 track averaging job
echo
echo "       " jobs for the cycle 6 hours later
echo
echo "   " forecast, copy, post and prdgen jobs $jjjf06 to $jjje06
typeset -RZ3 jjj=$jjjf06
typeset -RZ2 pp=00
while (( jjj < jjje06 ))
do
  (( pp = pp + 1 ))
  if (( pp > npert )); then
    pert=c00
  else
    pert=p$pp
  fi
  if [[ $RUN_CONCURRENT = no ]]; then
    echo $jjj forecast job for $pert
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for $pert
  elif (( pp == 1 )); then
    echo $jjj forecast job for all perturbations
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for all perturbations
  else
    (( jjj = jjj + 1 ))
  fi
  (( jjj = jjj + 1 ))
  echo $jjj post job for $pert
  (( jjj = jjj + 1 ))
  echo $jjj prdgen job for $pert
  (( jjj = jjj + 1 ))
done
echo
echo $jjjt06 tracking job
echo
echo "       " jobs for the cycle 12 hours later
echo
echo "   " forecast, copy, post and prdgen jobs $jjjf12 to $jjje12
typeset -RZ3 jjj=$jjjf12
typeset -RZ2 pp=00
while (( jjj < jjje12 ))
do
  (( pp = pp + 1 ))
  if (( pp > npert )); then
    pert=c00
  else
    pert=p$pp
  fi
  if [[ $RUN_CONCURRENT = no ]]; then
    echo $jjj forecast job for $pert
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for $pert
  elif (( pp == 1 )); then
    echo $jjj forecast job for all perturbations
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for all perturbations
  else
    (( jjj = jjj + 1 ))
  fi
  (( jjj = jjj + 1 ))
  echo $jjj post job for $pert
  (( jjj = jjj + 1 ))
  echo $jjj prdgen job for $pert
  (( jjj = jjj + 1 ))
done
echo
echo $jjjt12 tracking job
echo
echo "       " jobs for the cycle 18 hours later
echo
echo "   " forecast, post and prdgen jobs $jjjf18 to $jjje18
typeset -RZ3 jjj=$jjjf18
typeset -RZ2 pp=00
while (( jjj < jjje18 ))
do
  (( pp = pp + 1 ))
  if (( pp > npert )); then
    pert=c00
  else
    pert=p$pp
  fi
  if [[ $RUN_CONCURRENT = no ]]; then
    echo $jjj forecast job for $pert
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for $pert
  elif (( pp == 1 )); then
    echo $jjj forecast job for all perturbations
    (( jjj = jjj + 1 ))
    echo $jjj restart copy job for all perturbations
  else
    (( jjj = jjj + 1 ))
  fi
  (( jjj = jjj + 1 ))
  echo $jjj post job for $pert
  (( jjj = jjj + 1 ))
  echo $jjj prdgen job for $pert
  (( jjj = jjj + 1 ))
done
echo
echo $jjjt18 tracking job
echo $jjjc18 post cleanup job
echo
echo 900 betweeen production jobs and archive/cleanup jobs
echo 999 last job of cycle
echo

############################# joblist section end
if [[ $joblistflag = yes ]]; then
  echo `date` since joblist was requested, no other processing will be done
  echo
else
############################# joblist section end

#########################################################################################
echo
echo `date`                                                  setup order of job execution
echo
#########################################################################################

echo
echo `date` $0 $*                                        find next job number if required
echo

echo nextflag=$nextflag
if [[ $nextflag = yes ]]; then
  yyyymmddccb=$yyyymmddccc
  echo jjjc=$jjjc
  if   (( jjjc >= jjjp00 )) && (( jjjc < jjje00 )); then
    (( jjjd = jjjc - jjjf00 ))
    (( jjjm = ( jjjd / 4 ) * 4 ))
    if (( jjjd - jjjm == 3 )) && [[ $RUN_CONCURRENT = yes ]]; then
      jjjb=$(( jjjc + 3 ))
    else
      jjjb=$(( jjjc + 1 ))
    fi
  elif (( jjjc >= jjjr00 )) && (( jjjc < jjjz00 )); then
    jjjb=$(( jjjc + 1 ))
  elif (( jjjc >= jjjp00l )) && (( jjjc < jjje00l )); then
    (( jjjd = jjjc - jjjf00l ))
    (( jjjm = ( jjjd / 4 ) * 4 ))
    if (( jjjd - jjjm == 3 )) && [[ $RUN_CONCURRENT = yes ]]; then
      jjjb=$(( jjjc + 3 ))
    else
      jjjb=$(( jjjc + 1 ))
    fi
  elif (( jjjc >= jjjp06 )) && (( jjjc < jjje06 )); then
    (( jjjd = jjjc - jjjf06 ))
    (( jjjm = ( jjjd / 4 ) * 4 ))
    if (( jjjd - jjjm == 3 )) && [[ $RUN_CONCURRENT = yes ]]; then
      jjjb=$(( jjjc + 3 ))
    else
      jjjb=$(( jjjc + 1 ))
    fi
  elif (( jjjc >= jjjp12 )) && (( jjjc < jjje12 )); then
    (( jjjd = jjjc - jjjf12 ))
    (( jjjm = ( jjjd / 4 ) * 4 ))
    if (( jjjd - jjjm == 3 )) && [[ $RUN_CONCURRENT = yes ]]; then
      jjjb=$(( jjjc + 3 ))
    else
      jjjb=$(( jjjc + 1 ))
    fi
  elif (( jjjc >= jjjp18 )) && (( jjjc < jjje18 )); then
    (( jjjd = jjjc - jjjf18 ))
    (( jjjm = ( jjjd / 4 ) * 4 ))
    if (( jjjd - jjjm == 3 )) && [[ $RUN_CONCURRENT = yes ]]; then
      jjjb=$(( jjjc + 3 ))
    else
      jjjb=$(( jjjc + 1 ))
    fi
  else 
    case $jjjc in

      (000) jjjb=012 ;;
#DHOU 03/26/2012 skip ET and gfs for Zeus
#     (000) jjjb=100 ;;
      (012) jjjb=013 ;;
      (013) jjjb=014 ;;

      (014)
        echo rungfsprdgen=$rungfsprdgen
        case $rungfsprdgen in
          (yes)
            echo run the gfs prdgen next
            jjjb=$jjjg00
          ;;
          (no)
            echo do not run the gfs prdgen next
            jjjb=$jjjf00
          ;;
          (test)
            echo test whether to run gfs prdgen for rungfsprdgen=$rungfsprdgen
            yyyymmddb=`echo $yyyymmddccb|cut -c1-8`
            ccb=`echo $yyyymmddccb|cut -c9-10`
#           if [[ -a /com/gfs/prod/gfs.${yyyymmddb}/gfs.t${ccb}z.master.grbf06 ]]; then
            if [[ -a $basedgfs/$TMPCOM/gfs/prod/gfs.${yyyymmddb}/gfs.t${ccb}z.master.grbf06 ]]; then
              echo run the gfs prdgen next
              jjjb=$jjjg00
            else
              echo do not run the gfs prdgen next
              jjjb=$jjjf00
            fi
          ;;
          (*)
            echo
            echo `date` rungfsprdgen=$rungfsprdgen OPTION NOT RECOGNIZED
	    echo
            echo `date` $0 $* ABORT EXIT 4
            echo
            exit 4
          ;;
        esac
        echo after the last prdgen job jjjb=$jjjb
      ;;

      ($jjjg00) jjjb=$jjjf00 ;;
      #($jjjf00) jjjb=$jjjp00 ;;
      #                                     when running 6-hour cycling only
      #                                     use next line to skip the restart copy job
      ($jjjf00) (( jjjb=jjjp00 + 1 )) ;;
      ($jjje00) jjjb=$jjjs00 ;;
      ($jjjs00)
	if (( fcst_segments == 2 )); then
	  jjjb=$jjjr00
	else
	  jjjb=$jjjo00
	fi
      ;;
      ($jjjz00) jjjb=$jjjf00l ;;
      #($jjjf00l) jjjb=$jjjp00l ;;
      #                                       when skipping re-start copy
      ($jjjf00l) (( jjjb=jjjp00l + 1 )) ;;
      #        
      ($jjje00l) jjjb=$jjjs00l ;;
      ($jjjs00l) jjjb=$jjjo00 ;;
      ($jjjo00) jjjb=$jjjt00 ;;
#  DHOU 03/27/2012  use next line to skip track and track-average jobs ZEUS 
#     ($jjjo00) jjjb=900 ;;
      ($jjjt00) jjjb=$jjja00 ;;

# RLW 20150228 disable cqpf job
      ($jjja01) jjjb=$jjja01;;
       
      ($jjja00) 
	if [[ $runcyclingf = no ]]; then
	  jjjb=900 
	else
	  jjjb=$jjjf06 
	fi
      ;;

      ($jjjf06) (( jjjb=jjjp06 + 1 )) ;;
      ($jjje06) jjjb=$jjjt06 ;;
      ($jjjt06) jjjb=$jjjf12 ;;

      ($jjjf12) (( jjjb=jjjp12 + 1 )) ;;
      ($jjje12) jjjb=$jjjt12 ;;
      ($jjjt12) jjjb=$jjjf18 ;;

      ($jjjf18) (( jjjb=jjjp18 + 1 )) ;;
      ($jjje18) jjjb=$jjjt18 ;;
      #($jjjt18) jjjb=$jjjc18 ;;
      ($jjjt18) jjjb=900 ;;

      ($jjjc18) jjjb=900 ;;
      (900) jjjb=999 ;;
      (999)
	jjjb=000
	yyyymmddccb=`$NDATE +$fhrp $yyyymmddccc`
      ;;
      (*) 
	echo
	echo `date` jjjc=$jjjc NOT IDENTIFIED 
	echo
	echo `date` $0 $* ABORT EXIT 4
	echo
	exit 4
      ;;
    esac
  fi
  echo
fi
yyyymmddccjjjb=$yyyymmddccb$jjjb

echo 
echo `date` $0 $*                                   updated date and job number variables
echo

yyyymmddcc=$yyyymmddccb
jjj=$jjjb
yyyymmddccjjj=$yyyymmddccjjjb

echo yyyymmddccjjjc=$yyyymmddccjjjc
echo yyyymmddccc=$yyyymmddccc
echo jjjc=$jjjc
echo
echo yyyymmddccjjjb=$yyyymmddccjjjb
echo yyyymmddccb=$yyyymmddccb
echo jjjb=$jjjb
echo
echo yyyymmddccjjje=$yyyymmddccjjje
echo yyyymmddcce=$yyyymmddcce
echo jjje=$jjje
echo
echo yyyymmddccjjj=$yyyymmddccjjj
echo yyyymmddcc=$yyyymmddcc
echo jjj=$jjj
echo

yyyymmdd=`echo $yyyymmddcc|cut -c1-8`
cc=`echo $yyyymmddcc|cut -c9-10`
echo yyyymmdd=$yyyymmdd
echo cc=$cc
echo

PDY=`echo $yyyymmddcc | cut -c1-8`
cyc=`echo $yyyymmddcc | cut -c9-10`
echo PDY=$PDY "  " cyc=$cyc
echo `date` $0 create date and time variables
echo
PDYp2=`$NDATE +48 $yyyymmddcc|cut -c1-8`
PDYp1=`$NDATE +24 $yyyymmddcc|cut -c1-8`
PDY=$yyyymmdd
PDYm1=`$NDATE -24 $yyyymmddcc|cut -c1-8`
PDYm2=`$NDATE -48 $yyyymmddcc|cut -c1-8`
PDYm3=`$NDATE -72 $yyyymmddcc|cut -c1-8`
PDYm4=`$NDATE -96 $yyyymmddcc|cut -c1-8`
PDYm5=`$NDATE -120 $yyyymmddcc|cut -c1-8`

echo
echo PDYp2=$PDYp2
echo PDYp1=$PDYp1
echo PDY=$PDY
echo PDYm1=$PDYm1
echo PDYm2=$PDYm2
echo PDYm3=$PDYm3
echo PDYm4=$PDYm4
echo PDYm5=$PDYm5
echo


echo
echo `date` $0 test for end of run
echo

if (( yyyymmddcc > yyyymmddcce )); then
  echo
  echo `date` $yyyymmddcc is past the last cycle $yyyymmddcce
  echo
  echo
  echo `date` $0 $* end
  echo
  exit 1
fi
#set -x
if (( yyyymmddcc == yyyymmddcce )); then

  jjjt=$jjj
  jjjte=$jjje

  echo
  echo jjj=$jjj jjjt=$jjjt jjje=$jjje jjjte=$jjjte
  echo
  if (( jjjt > jjjte )); then
    echo
    echo based on $jjjt later than $jjjte
    echo job $jjj is later than $jjje for cycle $yyyymmddcc
    echo
    echo
    echo `date` $0 $* end
    echo
    exit 1
  fi
fi

echo 
echo `date` $0 $*                                  variables set before writing job cards
echo
echo production variables
echo
echo envir=$envir
echo PDY=$PDY
echo cyc=$cyc
echo
echo non-production variables
echo
echo expid=$expid
echo jjj=$jjj
echo

#########################################################################################
echo
echo `date`                                           setup task name based on job number
echo
#########################################################################################

cyc_os=0
fcstjoblength=

jobtype=none
forecast_segment=
if   (( jjj >= jjjf00 )) && (( jjj <= jjje00 )); then
  cyc_os=0
  (( jjjp = jjjf00 ))
  jobtype=fpp
  fcstjoblength=long
  forecast_segment=hr
elif (( jjj >= jjjr00 )) && (( jjj <= jjjz00 )); then
  cyc_os=0
  (( jjjr = jjjr00 ))
  jobtype=chgres
  fcstjoblength=short
elif (( jjj >= jjjf00l )) && (( jjj <= jjje00l )); then
  cyc_os=0
  (( jjjp = jjjf00l ))
  jobtype=fpp
  fcstjoblength=long
  forecast_segment=lr
elif (( jjj >= jjjf06 )) && (( jjj <= jjje06 )); then
  cyc_os=6
  (( jjjp = jjjf06 ))
  jobtype=fpp
  fcstjoblength=short
  forecast_segment=hr
elif (( jjj >= jjjf12 )) && (( jjj <= jjje12 )); then
  cyc_os=12
  (( jjjp = jjjf12 ))
  jobtype=fpp
  fcstjoblength=short
  forecast_segment=hr
elif (( jjj >= jjjf18 )) && (( jjj <= jjje18 )); then
  cyc_os=18
  (( jjjp = jjjf18 ))
  jobtype=fpp
  fcstjoblength=short
  forecast_segment=hr
else 
  case $jjj in
    (000) taskname=r000 ;;
    (012) taskname=init.separate ;;
    (013) taskname=init.et ;;
    (014) taskname=init.combine ;;
    ($jjjg00) 
      taskname=prdgen.gfs 
      fcstjoblength=long
    ;;
    ($jjjs00) 
      taskname=ensstat_hr
      fcstjoblength=long
    ;;
    ($jjjs00l) 
      taskname=ensstat_lr
      fcstjoblength=long
    ;;
    ($jjjo00) 
      taskname=enspost
      fcstjoblength=long
    ;;
    ($jjjt00) 
      taskname=post.track
      cyc_os=0
      fcstjoblength=long
    ;;
    ($jjja00) 
      taskname=track.ave
      cyc_os=0
      fcstjoblength=long
    ;;
    ($jjja01) 
      taskname=post.cqpf
      cyc_os=0
      fcstjoblength=long
    ;;
    ($jjjt06) 
      taskname=post.track
      cyc_os=6
      fcstjoblength=short
    ;;
    ($jjjt12) 
      taskname=post.track
      cyc_os=12
      fcstjoblength=short
    ;;
    ($jjjt18) 
      taskname=post.track
      cyc_os=18
      fcstjoblength=short
    ;;
    ($jjjc18) 
      taskname=post.cleanup
      cyc_os=18
      fcstjoblength=short
    ;;
    (900) taskname=r900 ;;
    (999) taskname=r999 ;;
    (*) 
      echo
      echo `date` jjj=$jjj NOT IDENTIFIED 
      echo `date` $0 $* exit 5
      echo
      exit 5
    ;;
  esac
fi

echo
echo jobtype=$jobtype

memn=
typeset -RZ2 memn
mem=
case $jobtype in
  (fpp)
    echo jjjp=$jjjp
    (( memn = ( jjj + 4 - jjjp ) / 4 ))
    (( jobn = ( jjj + 4 - jjjp ) - 4 * memn ))
    if (( memn > npert )); then
      memn=00
      mem=c00
    else
      mem=p$memn
    fi
    echo memn=$memn
    echo jobn=$jobn
    case $jobn in
      (0)
	taskname=forecast_$forecast_segment
	if [[ $RUN_CONCURRENT = yes ]]; then
	  mem=
	  memn=
	fi
      ;;
      (1)
	taskname=restart_copy_$forecast_segment
      ;;
      (2)
	taskname=nceppost_$forecast_segment
      ;;
      (3)
	taskname=post.prdgen_$forecast_segment
      ;;
    esac
  ;;
  (chgres)
    echo jjjr=$jjjr
    (( memn = ( jjj - jjjr ) ))
    echo memn=$memn
    if (( memn == 0 )); then
      mem=c00
    else
      mem=p$memn
    fi
    taskname=chgres
  ;;
  (none)
    echo taskname=$taskname has already been selected
  ;;
  (*)
    echo jobtype=$jobtype IS UNDEFINED
    exit 8
  ;;
esac
echo
echo mem=$mem
echo memn=$memn
echo taskname=$taskname

#########################################################################################
echo
echo `date`                                    setup forecast length for development runs
echo
#########################################################################################

echo before reset for experiments: fhmax=$fhmax fcstjoblength=$fcstjoblength

if [[ $fcstjoblength = long ]]; then
  if (( fhmax <= 6 )); then
    fcstjoblength=short
  fi
fi

echo
echo after reset for experiments: fhmax=$fhmax fcstjoblength=$fcstjoblength
echo

#########################################################################################
echo
echo `date`                                            setup cyc_fcst based on job number
echo
#########################################################################################

################################################################################
# at this point the cycle offset cyc_os is converted to cyc_fcst
# which is the actual cycle for which a cycling job is submitted
################################################################################

echo
echo cyc_os=$cyc_os
echo
typeset -Z2 cyc_fcst
(( cyc_fcst = cyc + cyc_os ))
if (( cyc_fcst >= 24 )); then
  (( cyc_fcst = cyc_fcst - 24 ))
fi

echo
echo mem=$mem
echo memn=$memn
echo taskname=$taskname
echo cyc_fcst=$cyc_fcst
echo

echo
echo `date` $0 $*                                          initialize limits and requests
echo

jobscript=
job_name=
job_type=
node_usage=
total_tasks=
node=
wall_clock_limit=
resources=
node_resources=
task_affinity=
parallel_threads=
network_MPI=
MP_SHARED_MEMORY=
MEMORY_AFFINITY=
job=

during_previous_job=no

#########################################################################################
echo
echo `date`                               setup time limits for forecast and related jobs
echo
#########################################################################################
#
# settings used for long and short development jobs 
# of the following types which can all run at the same time
# forecast, post, prdgen, prdgen.gfs, ensstat 
#

wall_clock_limit_fcst_long="00:60:00"
wall_clock_limit_fcst_long="03:30:00"
wall_clock_limit_fcst_long="00:15:00"
wall_clock_limit_fcst_short="00:10:00"
wall_clock_limit_fcst_short="00:30:00"
wall_clock_limit_fcst_long="02:30:00"
  if [[ $gefsmachine = wcoss ]]; then                       
wall_clock_limit_fcst_long="1:30"
wall_clock_limit_fcst_short="00:10"
wall_clock_limit_fcst_short="00:15"
wall_clock_limit_fcst_short="00:20"
  fi
  if [[ $gefsmachine = dell ]]; then                       
wall_clock_limit_fcst_long="3:30"
wall_clock_limit_fcst_short="00:40"
  fi

echo wall_clock_limit_fcst_long=$wall_clock_limit_fcst_long
echo wall_clock_limit_fcst_short=$wall_clock_limit_fcst_short

#########################################################################################
echo
echo `date`                                        setup requirements for submitting jobs
echo
#########################################################################################
#
# default space limit before a job will be submitted
# may be reset for individual jobs
# in gigabytes
#

splim=101001001

#
# maximum number of jobs to be allowed to run at once
# if exceeded, the next job waits
#
# coordinate these settings with other runs

joblim=60        #
joblim=60        #
joblimdev=54     #
joblimdev=54     #
joblimdevhigh=20 #
joblimdevhigh=44 #

(( miwait = 15 ))
(( miwait = 5  ))  #DHOU, 08/06/2010 to reduce wait time
(( miwait = 12 ))  # RLW 20101130 coordinate with rwid
(( miwait = 4  ))  # RLW 20101130 coordinate with rwid
# see shorter and longer settings below

#
# maximum number of jobs to be allowed in loadleveler
# if exceeded, abort
#

jobmax=80

#
# maximum total number of jobs to be allowed in loadleveler
# if exceeded, wait a long time
#

jobtotlim=700

echo default splim=$splim
echo joblim=$joblim
echo joblimdev=$joblimdev
echo joblimdevhigh=$joblimdevhigh
echo jobmax=$jobmax
echo jobtotlim=$jobtotlim

#########################################################################################
echo
echo `date`                                    setup resource requests based on task name
echo
#########################################################################################

case $taskname in
  (r000)
    ################################# development variables
    jobscript=control.r000
    jobdir=$controldir
    job_name=jd000
    during_previous_job=no
    job_type=serial
#   wall_clock_limit="00:19:00"
#   resources="ConsumableCpus(1) ConsumableMemory(1650 MB)" #droped for Zeus
    resources="1650M"
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="00:10"
    resources=1650
    MP_SHARED_MEMORY=yes
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="00:10"
    resources=1650
    MP_SHARED_MEMORY=yes
    RUN=
  fi  
  ;;
  (init.separate)
    ################################# production variables
    jobscript=JGEFS_INIT_SEPARATE
    job_name=jgefs_init_separate_$cyc
    job_type=parallel
    total_tasks=40
    node=1
    wall_clock_limit="01:50:00"
    resources="ConsumableMemory(1500 MB)"
    task_affinity="cpu(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    job=gefs_init_separate_$cyc
    ################################# development variables
    during_previous_job=no
    splim=301001001
    ################################# production variables modified
    resources="ConsumableMemory(3500 MB)"  #DHOU 08/20 for T254L42
    network_MPI="sn_all,shared,us"
    resources=
    node_usage=not_shared
    node_resources="ConsumableMemory(110 GB)"
    task_affinity="core(1)"
    node=2   #DHOU 08/20 for T254L42
    total_tasks=40
#DHOU 04/04/2012 for ZEUS, T254L42
  if [[ $gefsmachine = zeus ]]; then                       
    node=4   #DHOU 04/04/2012 for ZEUS, T254L42
  fi  
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="01:50"
    taskspernode=10
    OMP_NUM_THREADS=1
    MP_SHARED_MEMORY=no
    # 20170814 RLW to match production
    taskspernode=2
    taskspernode=1
    taskspernode=8
    task_affinity="core(2)"
    OMP_NUM_THREADS=2
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="01:50"
    total_tasks=40
    taskspernode=8
    taskspernode=14
    node=3
    OMP_NUM_THREADS=2
    MP_SHARED_MEMORY=no
  fi  
  ;;
  (init.et)
    ################################# production variables
    jobscript=JGEFS_INIT_ET
    job_name=tgefs_init_et_$cyc
    job_type=parallel
    total_tasks=10
    node=1
    wall_clock_limit="01:50:00"
    resources="ConsumableMemory(8000 MB)"
    task_affinity="cpu(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    job=GEFS_init_ET_$cyc
    ################################# development variables
    during_previous_job=no
    splim=301001001
    (( total_tasks = npair ))
    ################################# production variables modified
# DHOU 08/03/2010  for T254L42, 20 pert. members, use 4 nodes, 40 tasks
# These numbers can be reduced, but test is needed
     (( total_tasks = npair * 4 ))
     resources="ConsumableMemory(10 GB)"
     node=4
    resources=
    node_usage=not_shared
    node_resources="ConsumableMemory(110 GB)"
    network_MPI="sn_all,shared,us"
    task_affinity="core(1)"
    total_tasks=240
    node=3
  if [[ $gefsmachine = zeus ]]; then                       
    node=7   #DHOU 04/04/2012 for ZEUS, T254L42
  fi  
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="01:50"
    taskspernode=10
    OMP_NUM_THREADS=1
    MP_SHARED_MEMORY=no
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="01:50"
    total_tasks=160
    taskspernode=20 
    node=8
    OMP_NUM_THREADS=1
    MP_SHARED_MEMORY=no
  fi  

  ;;
  (init.combine)
    ################################# production variables
    jobscript=JGEFS_INIT_COMBINE
    job_name=tgefs_init_combine_$cyc
    job_type=parallel
    total_tasks=40
    node=1
    wall_clock_limit="01:50:00"
    resources="ConsumableMemory(1500 MB)"
    task_affinity="cpu(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    job=gefs_init_combine_$cyc
    ################################# development variables
    during_previous_job=no
    splim=301001001
    ################################# production variables modified
## RLW 20110209 test for relocation with T254
    resources="ConsumableMemory(5500 MB)"
    node=2
    network_MPI="sn_all,shared,us"
    resources=
    node_usage=not_shared
    node_resources="ConsumableMemory(110 GB)"
    task_affinity="core(1)"
    node=2   #DHOU 08/20 for T254L42
    total_tasks=40
#DHOU 04/04/2012 for ZEUS, T254L42
    node=4   
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="01:50"
    taskspernode=10
    OMP_NUM_THREADS=1
    MP_SHARED_MEMORY=no
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="01:50"
    total_tasks=40
    taskspernode=20
    node=2
    OMP_NUM_THREADS=2
    MP_SHARED_MEMORY=no
  fi  
  ;;
  (forecast_hr)
    FORECAST_SEGMENT=hr
    ################################# production variables
    jobscript=JGEFS_FORECAST
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_forecast_${cyc}
      wall_clock_limit="00:60:00"
    else
      job_name=jgefs_forecast_cf${cyc_fcst}_${cyc}
      wall_clock_limit="00:60:00"
    fi
    job_type=parallel
    node_usage=not_shared
    total_tasks=420
    node=14
    network_MPI="sn_all,shared,us"
    node_resources="ConsumableMemory(110 GB)"
    task_affinity="core(1)"
    parallel_threads=2
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    job=gefs_forecast_${cyc}
    ################################# development variables
    node_usage=shared
    during_previous_job=no
    splim=301001001
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
      # this task formula reproduces production for npert=20
      (( total_tasks = 20 * (npert + 1) ))
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
      # this task formula reproduces production for npert=20
      (( total_tasks = 21 * npert ))
    fi
    # this node formula reproduces production for npert=20 and parallel_threads=2
    (( node = ( total_tasks + 31 ) / 32 ))
##DHOU, 08/20/2010 modified J-job script for option of old/new gfs
    jobscript=JGEFS_FORECAST

   ############ DHOU, 08/20/2010, suggested resources for T254L42 on VAPOR dev mode
   ###### This section should be modified based on RESOLUTION and parallel_threads
     #export RERUN=YES
     node_usage=not_shared
     task_affinity="cpu(1)"     # DHOU, core(1) not run for thread=1
     parallel_threads=1         # DHOU, to get enough memory with less tasks
     if [[ $fcstjoblength = long ]]; then
       wall_clock_limit="$wall_clock_limit_fcst_long"
       (( taskspermem = 36 ))
       (( taskspermem = 39 )) # RLW 20110420 after SegFault twice with 36
       #(( taskspermem = 42 )) # RLW 20101218 after SegFault twice with 36
       #(( taskspermem = 45 )) # RLW 20110101 after SegFault two cycles with 42
       #(( taskspermem = 48 )) # RLW 20110102 after SegFault with 45
       #(( taskspermem = 51 )) # RLW 20110103 after SegFault with 48
       #(( taskspermem = 54 )) # RLW 20110104 after SegFault with 41
       (( taskspermem = 91 )) # RLW 20110727 30 nodes
       task_affinity="core(1)"     # RLW 20010801
       task_affinity="cpu(1)"     # RLW 20010801
       # RLW 20110804 see below
     else
       wall_clock_limit="$wall_clock_limit_fcst_short"
       (( taskspermem = 16 ))
       (( taskspermem = 24 ))         # RWOBUS test to match rwir
       parallel_threads=2            # RWOBUS test to match rwir
       task_affinity="core(1)"       # RWOBUS test to match rwir
       # RLW 20110804 see below
     fi
     # RLW 20110804 forecast settings 4 now required
     if [[ $fcstjoblength = long ]]; then
       (( taskspermem = 64 ))
       parallel_threads=2
       task_affinity="core(1)"
       taskspernode=32
     else
       (( taskspermem = 32 ))
       parallel_threads=2
       task_affinity="core(1)"
       taskspernode=32
     fi

#DHOU add this for ZEUS
# machl=`uname -n | cut -c1`
# if [[ $machl = r ]]; then                       
#      machl=f
# fi
  if [[ $gefsmachine = zeus ]]; then                       
       (( taskspermem = 40 ))
       parallel_threads=1
       task_affinity="core(1)"
       taskspernode=12
  fi
  if [[ $gefsmachine = wcoss ]]; then                       
     if [[ $fcstjoblength = long ]]; then
#      (( taskspermem = 96 ))
#      (( taskspermem = 100 ))
       (( taskspermem = 80 ))
     else  
       (( taskspermem = 32 ))
     fi  
       parallel_threads=1
       task_affinity="core(1)"
       (( taskspernode = $COREPERNODE / parallel_threads ))
       export taskspernode=$taskspernode
       export OMP_NUM_THREADS=$parallel_threads
       MP_SHARED_MEMORY=no
  fi
  if [[ $gefsmachine = dell ]]; then                       
     if [[ $fcstjoblength = long ]]; then
#      (( taskspermem = 96 ))
#      (( taskspermem = 100 ))
#      (( taskspermem = 80 ))
       (( taskspermem = 40 ))
     else  
       (( taskspermem = 18 ))
     fi  
       parallel_threads=1
       task_affinity="core(1)"
       (( taskspernode = $COREPERNODE / parallel_threads ))
       export taskspernode=$taskspernode
       export OMP_NUM_THREADS=$parallel_threads
       MP_SHARED_MEMORY=no
  fi

     if [[ $RUN_CONCURRENT = yes ]]; then
       if [[ $cyc = $cyc_fcst ]]; then
         (( total_tasks = taskspermem * (npert + 1) ))
       else
         (( total_tasks = taskspermem * npert ))
       fi
     else
       (( total_tasks = taskspermem ))
       RUN=ge$mem
     fi
     (( node = ( total_tasks + taskspernode - 1 ) / taskspernode ))
  ;;
  (forecast_lr)
    FORECAST_SEGMENT=lr
    ################################# production variables
    jobscript=JGEFS_FORECAST
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_forecast_${cyc}
      wall_clock_limit="00:60:00"
    else
      job_name=jgefs_forecast_cf${cyc_fcst}_${cyc}
      wall_clock_limit="00:60:00"
    fi
    job_type=parallel
    node_usage=not_shared
    total_tasks=420
    node=14
    network_MPI="sn_all,shared,us"
    node_resources="ConsumableMemory(110 GB)"
    task_affinity="core(1)"
    parallel_threads=2
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    job=gefs_forecast_${cyc}
    ################################# development variables
    node_usage=shared
    during_previous_job=no
    splim=301001001
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
      # this task formula reproduces production for npert=20
      (( total_tasks = 20 * (npert + 1) ))
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
      # this task formula reproduces production for npert=20
      (( total_tasks = 21 * npert ))
    fi
    # this node formula reproduces production for npert=20 and parallel_threads=2
    (( node = ( total_tasks + 31 ) / 32 ))
##DHOU, 08/20/2010 modified J-job script for option of old/new gfs
    jobscript=JGEFS_FORECAST

   ############ DHOU, 08/20/2010, suggested resources for T254L42 on VAPOR dev mode
   ###### This section should be modified based on RESOLUTION and parallel_threads
     export RERUN=YES
     node_usage=not_shared
     task_affinity="cpu(1)"     # DHOU, core(1) not run for thread=1
     parallel_threads=1         # DHOU, to get enough memory with less tasks

     if [[ $fcstjoblength = long ]]; then
       wall_clock_limit="$wall_clock_limit_fcst_long"
       (( taskspermem = 36 ))
       (( taskspermem = 39 )) # RLW 20110420 after SegFault twice with 36
       #(( taskspermem = 42 )) # RLW 20101218 after SegFault twice with 36
       #(( taskspermem = 45 )) # RLW 20110101 after SegFault two cycles with 42
       #(( taskspermem = 48 )) # RLW 20110102 after SegFault with 45
       #(( taskspermem = 51 )) # RLW 20110103 after SegFault with 48
       #(( taskspermem = 54 )) # RLW 20110104 after SegFault with 41
       # RLW 20110804 see below
     else
       wall_clock_limit="$wall_clock_limit_fcst_short"
       (( taskspermem = 16 ))
       (( taskspermem = 24 ))         # RWOBUS test to match rwir
       parallel_threads=2            # RWOBUS test to match rwir
       task_affinity="core(1)"       # RWOBUS test to match rwir
       # RLW 20110804 see below
     fi
     # RLW 20110804 forecast settings 4 now required
     (( taskspermem = 32 ))
     parallel_threads=2
     task_affinity="core(1)"
     taskspernode=32
#DHOU  03/26/2012 add this for ZEUS
# machl=`uname -n | cut -c1`
# if [[ $machl = r ]]; then                       
#      machl=f
# fi
  if [[ $gefsmachine = zeus ]]; then                       
       (( taskspermem = 40 ))
       parallel_threads=1
       task_affinity="core(1)"
       taskspernode=12
  fi
  if [[ $gefsmachine = wcoss ]]; then                       
#      (( taskspermem = 48 ))
       (( taskspermem = 32 ))
       parallel_threads=1
       task_affinity="core(1)"
       (( taskspernode = $COREPERNODE / parallel_threads ))
       export taskspernode=$taskspernode
       export OMP_NUM_THREADS=$parallel_threads
       MP_SHARED_MEMORY=no
  fi
  if [[ $gefsmachine = dell ]]; then                       
#      (( taskspermem = 48 ))
       (( taskspermem = 18 ))
       parallel_threads=1
       task_affinity="core(1)"
       (( taskspernode = $COREPERNODE / parallel_threads ))
       export taskspernode=$taskspernode
       export OMP_NUM_THREADS=$parallel_threads
       MP_SHARED_MEMORY=no
  fi

     if [[ $RUN_CONCURRENT = yes ]]; then
       if [[ $cyc = $cyc_fcst ]]; then
         (( total_tasks = taskspermem * (npert + 1) ))
       else
         (( total_tasks = taskspermem * npert ))
       fi
     else
       (( total_tasks = taskspermem ))
       RUN=ge$mem
     fi
     (( node = ( total_tasks + taskspernode - 1 ) / taskspernode ))
  ;;
  (chgres)
    ################################# production variables
    jobscript=JGEFS_SIGCHGRES
    job_type=parallel
    total_tasks=8
    node=1
    parallel_threads=2
    resources="ConsumableMemory(1000 MB)"
    network_MPI="sn_all,shared,us"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    RUN=ge$mem
    task_affinity="core(1)"
    ################################# development variables
    if (( jjjb == jjjr00 )); then
      during_previous_job=no
    else
      during_previous_job=yes
    fi
    ################################# production variables modified
  if [[ $gefsmachine = ccs ]]; then                       
    total_tasks=$(( NTHREADS_SIGCHGRS * 2 ))
  fi  
  if [[ $gefsmachine = zeus ]]; then                       
#DHOU 03/29/2012   chgres is a non-mpi program
    job_type=serial
    resources="1000M"
    resources="4000M"
    total_tasks=1 
#   job_type=parallel
#   total_tasks=8
    node=1
      wall_clock_limit="00:20:00"
  fi    
  if [[ $gefsmachine = wcoss ]]; then                       
#DHOU 03/29/2012   chgres is a non-mpi program
    job_type=parallel
    total_tasks=1 
    (( taskspernode = 16 / NTHREADS_SIGCHGRS ))
    export taskspernode=$taskspernode
    export OMP_NUM_THREADS=$NTHREADS_SIGCHGRS
    echo NTHREADS_SIGCHRS=$NTHREADS_SIGCHGRS
    wall_clock_limit="00:20"
    MP_SHARED_MEMORY=yes
    total_tasks=1
    taskspernode=1
    OMP_NUM_THREADS=4
    resources=1000
   fi
  if [[ $gefsmachine = dell ]]; then                       
#DHOU 03/29/2012   chgres is a non-mpi program
    job_type=parallel
    total_tasks=1 
    (( taskspernode = 28 / NTHREADS_SIGCHGRS ))
    export taskspernode=$taskspernode
    export OMP_NUM_THREADS=$NTHREADS_SIGCHGRS
    echo NTHREADS_SIGCHRS=$NTHREADS_SIGCHGRS
    wall_clock_limit="00:20"
    MP_SHARED_MEMORY=yes
    total_tasks=1
    taskspernode=1
    OMP_NUM_THREADS=4
    resources=1000
   fi
  ;;
  (restart_copy_hr)
    FORECAST_SEGMENT=hr
    ################################# production variables
    jobscript=JGEFS_RESTART_COPY
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_restart_copy_${mem}_${cyc}
      wall_clock_limit="01:30:00"
  if [[ $gefsmachine = wcoss ]]; then                       
      wall_clock_limit="01:30"
  fi
      job=gefs_${mem}_post_${cyc}
    else
      job_name=jgefs_restart_copy_${mem}_cf${cyc_fcst}_${cyc}
      wall_clock_limit="01:30:00"
  if [[ $gefsmachine = wcoss ]]; then                       
      wall_clock_limit="01:30"
      MP_SHARED_MEMORY=yes
  fi
      job=gefs_${mem}_post_cf${cyc_fcst}_${cyc}
    fi
    job_type=parallel
    job_type=serial
    task_affinity="core(1)"
    task_affinity="cpu(1)"
    total_tasks=1
#   node=1
#   resources="ConsumableMemory(1000 MB)"
    resources="1000 M"
    network_MPI="sn_all,shared,us"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    if [[ $RUN_CONCURRENT != yes ]]; then
      RUN=ge$mem
    fi
    ################################# development variables
    during_previous_job=yes
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
    case $gefsmachine in
      (wcoss)
	resources=1000
	task_affinity="core(1)"
	MP_SHARED_MEMORY=yes
      ;;
      (dell)
	resources=500
	resources=1000
	task_affinity="core(1)"
	MP_SHARED_MEMORY=yes
      ;;
    esac
  ;;
  (restart_copy_lr)
    FORECAST_SEGMENT=lr
    ################################# production variables
    jobscript=JGEFS_RESTART_COPY
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_restart_copy_${mem}_${cyc}
      wall_clock_limit="01:30:00"
  if [[ $gefsmachine = wcoss ]]; then                       
      wall_clock_limit="01:30"
  fi
      job=gefs_${mem}_post_${cyc}
    else
      job_name=jgefs_restart_copy_${mem}_cf${cyc_fcst}_${cyc}
      wall_clock_limit="01:30:00"
  if [[ $gefsmachine = wcoss ]]; then                       
      wall_clock_limit="01:30"
      MP_SHARED_MEMORY=yes
  fi
      job=gefs_${mem}_post_cf${cyc_fcst}_${cyc}
    fi
    job_type=parallel
    job_type=serial
    task_affinity="core(1)"
    task_affinity="cpu(1)"
    total_tasks=1
    node=1
#   resources="ConsumableMemory(1000 MB)"
    resources="1000M"
    network_MPI="sn_all,shared,us"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    if [[ $RUN_CONCURRENT != yes ]]; then
      RUN=ge$mem
    fi
    ################################# development variables
    during_previous_job=yes
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
    case $gefsmachine in
      (wcoss)
	resources=1000
	task_affinity="core(1)"
	MP_SHARED_MEMORY=yes
      ;;
    esac
  ;;
  (nceppost_hr)
    ################################# production variables
    FORECAST_SEGMENT=hr
    jobscript=JGEFS_NCEPPOST
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_${mem}_post_${cyc}
      wall_clock_limit="01:30:00"
      job=gefs_${mem}_post_${cyc}
    else
      job_name=jgefs_${mem}_post_cf${cyc_fcst}_${cyc}
      wall_clock_limit="01:30:00"
      job=gefs_${mem}_post_cf${cyc_fcst}_${cyc}
    fi
    job_type=parallel
    total_tasks=4
    node=1
    network_MPI="sn_all,shared,us"
#   resources="ConsumableMemory(1000 MB)"  # droped for ZEUS
    parallel_threads=2
    task_affinity="core(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    RUN=ge$mem
    ################################# development variables
    during_previous_job=yes
    splim=301001001
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
    total_tasks=8
    case $gefsmachine in
      (wcoss)
        taskspernode=$total_tasks
	OMP_NUM_THREADS=1
	MP_SHARED_MEMORY=yes
	resources="2000"
      ;;
      (dell)
        taskspernode=$total_tasks
	OMP_NUM_THREADS=1
	MP_SHARED_MEMORY=yes
	resources="2000"
      ;;
    esac
  ;;
  (nceppost_lr)
    ################################# production variables
    FORECAST_SEGMENT=lr
    jobscript=JGEFS_NCEPPOST
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_${mem}_post_${cyc}
      wall_clock_limit="01:30:00"
      job=gefs_${mem}_post_${cyc}
    else
      job_name=jgefs_${mem}_post_cf${cyc_fcst}_${cyc}
      wall_clock_limit="01:30:00"
      job=gefs_${mem}_post_cf${cyc_fcst}_${cyc}
    fi
    job_type=parallel
    total_tasks=4
    node=1
    network_MPI="sn_all,shared,us"
#   resources="ConsumableMemory(1000 MB)"
    parallel_threads=2
    task_affinity="core(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    RUN=ge$mem
    ################################# development variables
    during_previous_job=yes
    splim=301001001
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
    total_tasks=8
    case $gefsmachine in
      (wcoss)
        taskspernode=$total_tasks
	OMP_NUM_THREADS=1
	MP_SHARED_MEMORY=yes
	resources="2000"
      ;;
      (dell)
        taskspernode=$total_tasks
	OMP_NUM_THREADS=1
	MP_SHARED_MEMORY=yes
	resources="2000"
      ;;
    esac
  ;;
  (post.prdgen_hr)
    FORECAST_SEGMENT=hr
    ################################# production variables
    jobscript=JGEFS_PRDGEN
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_${mem}_prdgen_${cyc}
      wall_clock_limit="01:30:00"
      job=gefs_${mem}_prdgen_${cyc}
    else
      job_name=jgefs_${mem}_prdgen_cf${cyc_fcst}_${cyc}
      wall_clock_limit="01:30:00"
      job=gefs_${mem}_prdgen_cf${cyc_fcst}_${cyc}
    fi
#   job_type=parallel
#   total_tasks=8
    job_type=serial
    total_tasks=1
    node=1
    network_MPI="sn_all,shared,us"
#   resources="ConsumableMemory(800 MB)"
    resources="800M"
    task_affinity="core(2)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    RUN=ge$mem
    ################################# development variables
    during_previous_job=yes
    splim=301001001
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
    case $gefsmachine in
      (wcoss)
	MP_SHARED_MEMORY=yes
	resources="200"
      ;;
      (dell)
	MP_SHARED_MEMORY=yes
	resources="200"
      ;;
    esac
  ;;
  (post.prdgen_lr)
    FORECAST_SEGMENT=lr
    ################################# production variables
    jobscript=JGEFS_PRDGEN
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_${mem}_prdgen_${cyc}
      wall_clock_limit="01:30:00"
      job=gefs_${mem}_prdgen_${cyc}
    else
      job_name=jgefs_${mem}_prdgen_cf${cyc_fcst}_${cyc}
      wall_clock_limit="01:30:00"
      job=gefs_${mem}_prdgen_cf${cyc_fcst}_${cyc}
    fi
#   job_type=parallel
#   total_tasks=8
    job_type=serial
    total_tasks=1
    node=1
    network_MPI="sn_all,shared,us"
#   resources="ConsumableMemory(800 MB)"
    resources="800M"
    task_affinity="core(2)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    RUN=ge$mem
    ################################# development variables
    during_previous_job=yes
    splim=301001001
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
    total_tasks=8
    case $gefsmachine in
      (wcoss)
	MP_SHARED_MEMORY=yes
	resources="200"
      ;;
      (dell)
	MP_SHARED_MEMORY=yes
	resources="200"
      ;;
    esac
  ;;
  (prdgen.gfs)
    ################################# production variables
    jobscript=JGEFS_PRDGEN_GFS
    job_name=jgefs_prdgen_gfs_$cyc
    job_type=serial
    resources="ConsumableMemory(500 MB)"
    task_affinity="cpu(2)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    job=gefs_prdgen_gfs_${cyc}
    ################################# development variables
    during_previous_job=yes
    fcstjoblength=long
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
    case $gefsmachine in
      (wcoss)
	MP_SHARED_MEMORY=yes
	resources="1000"
	resources="2000"     # RLW 20170315 ran out of memory for next GFS
      ;;
      (dell)
	MP_SHARED_MEMORY=yes
	resources="1000"
	resources="2000"     # RLW 20170315 ran out of memory for next GFS
      ;;
    esac
  ;;
  (ensstat_hr)
    FORECAST_SEGMENT=hr
    ################################# production variables
    jobscript=JGEFS_ENSSTAT
    job_type=serial
    wall_clock_limit="01:30:00"
#   resources="ConsumableMemory(500 MB)"
    resources="800M"
    task_affinity="cpu(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    MP_INFOLEVEL=2
    job=gefs_ensstat_${cyc}
    # insert modifications to production resources here
    ################################# development variables
    during_previous_job=yes
    splim=301001001
    fcstjoblength=long
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
#DHOU 04/19/2012 ZEUS
#   job_type=parallel
#   total_tasks=8
  if [[ $gefsmachine = wcoss ]]; then                       
      total_tasks=1
      MP_SHARED_MEMORY=yes
      resources=100
  fi
  if [[ $gefsmachine = dell ]]; then                       
      total_tasks=1
      MP_SHARED_MEMORY=yes
      resources=100
  fi
  ;;
  (ensstat_lr)
    FORECAST_SEGMENT=lr
    ################################# production variables
    jobscript=JGEFS_ENSSTAT
    job_type=serial
    wall_clock_limit="01:30:00"
#   resources="ConsumableMemory(500 MB)"
    resources="800M"
    task_affinity="cpu(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    MP_INFOLEVEL=2
    job=gefs_ensstat_${cyc}
    # insert modifications to production resources here
    ################################# development variables
    during_previous_job=yes
    splim=301001001
    fcstjoblength=long
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
#DHOU 04/19/2012 ZEUS
#   job_type=parallel
#   total_tasks=8
  if [[ $gefsmachine = wcoss ]]; then                       
      total_tasks=1
      MP_SHARED_MEMORY=yes
      resources=100
  fi
  if [[ $gefsmachine = dell ]]; then                       
      total_tasks=1
      MP_SHARED_MEMORY=yes
      resources=100
  fi
  ;;
  (enspost)
    ################################# production variables
    jobscript=JGEFS_ENSPOST
    job_type=serial
    wall_clock_limit="01:30:00"
#   resources="ConsumableMemory(500 MB)"
    resources="800M"
    task_affinity="cpu(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    MP_INFOLEVEL=2
    job=gefs_enspost_${cyc}
    # insert modifications to production resources here
    ################################# development variables
    during_previous_job=yes
    splim=301001001
    fcstjoblength=long
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
  if [[ $gefsmachine = wcoss ]]; then                       
      total_tasks=1
      MP_SHARED_MEMORY=yes
      resources=100
  fi
  if [[ $gefsmachine = dell ]]; then                       
      total_tasks=1
      MP_SHARED_MEMORY=yes
      resources=100
  fi
  ;;
  (post.track)
    ################################# production variables
    jobscript=JGEFS_POST_TRACK
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_post_track_${cyc}
      wall_clock_limit="01:00:00"
      task_affinity="cpu(2)"
      job=gefs_post_track_${cyc}
    else
      job_name=jgefs_post_track_cf${cyc_fcst}_${cyc}
      wall_clock_limit="01:30:00"
      task_affinity="cpu(2)"
      job=gefs_post_track_cf${cyc_fcst}_${cyc}
    fi
    job_type=parallel
    node_usage=not_shared
    tasks_per_node=1
    node=1
#   resources="ConsumableMemory(500 MB)"
    resources="1200M"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    ################################# development variables
    during_previous_job=no
    ################################# production variables modified
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="01:30"
    taskspernode=1
    OMP_NUM_THREADS=1
    MP_SHARED_MEMORY=no
    total_tasks=1
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="01:30"
    taskspernode=1
    OMP_NUM_THREADS=1
    MP_SHARED_MEMORY=no
    total_tasks=1
  fi  
  ;;
  (track.ave)
    ################################# production variables
    jobscript=JGEFS_ENS_TRAK_AVE
    if [[ $fcstjoblength = long ]]; then
      job_name=jgefs_trak_ave_${cyc}
      wall_clock_limit="01:10:00"
      task_affinity="cpu(2)"
      job=gefs_post_track_${cyc}
    else
      job_name=jgefs_trak_ave_cf${cyc_fcst}_${cyc}
      wall_clock_limit="01:10:00"
      task_affinity="cpu(2)"
      job=gefs_post_track_cf${cyc_fcst}_${cyc}
    fi
    job_type=serial
##  resources="ConsumableMemory(500 MB)"
    resources="500M"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    ################################# development variables
    during_previous_job=no
    ################################# production variables modified
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="01:10"
    MP_SHARED_MEMORY=yes
    resources=100
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="01:30"
    taskspernode=1
    OMP_NUM_THREADS=1
    MP_SHARED_MEMORY=yes
    total_tasks=1
    resources=1000
  fi  
  ;;
 (post.cqpf)
    ################################# production variables
    jobscript=JGEFS_CQPF
    job_type=serial
    wall_clock_limit="00:30:00"
#   resources="ConsumableMemory(500 MB)"
    resources="800M"
    task_affinity="cpu(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    MP_INFOLEVEL=2
    job=gefs_cqpf_${cyc}
    # insert modifications to production resources here
    ################################# development variables
    during_previous_job=yes
    splim=301001001
    fcstjoblength=long
    ################################# production variables modified
    if [[ $fcstjoblength = long ]]; then
      wall_clock_limit="$wall_clock_limit_fcst_long"
    else
      wall_clock_limit="$wall_clock_limit_fcst_short"
    fi
  if [[ $gefsmachine = wcoss ]]; then
      total_tasks=1
      MP_SHARED_MEMORY=yes
      resources=1000
  fi
  ;;

  (post.cleanup)
    ################################# production variables
    jobscript=JGEFS_POST_CLEANUP
    job_name=jgefs_post_cleanup_${cyc}
    job_type=serial
    wall_clock_limit="00:30:00"
    resources="ConsumableMemory(1650 MB)"
    task_affinity="cpu(1)"
    MP_SHARED_MEMORY=yes
    MEMORY_AFFINITY=MCM
    job=gefs_post_cleanup_${cyc}
    ################################# development variables
    during_previous_job=no
    ################################# production variables modified
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="01:10"
    MP_SHARED_MEMORY=yes
    resources=1000
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="00:30"
    MP_SHARED_MEMORY=yes
    resources=1000
  fi  
  ;;
  (r900)
    ################################# development variables
    jobscript=control.r900
    jobdir=$controldir
    job_name=
    during_previous_job=no
    job_type=serial
#   wall_clock_limit="00:49:00"
#   resources="ConsumableCpus(1) ConsumableMemory(1650 MB)"
    wall_clock_limit="00:29:00"
    resources="1650M"
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="00:10"
    MP_SHARED_MEMORY=yes
    resources=1000
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="00:10"
    MP_SHARED_MEMORY=yes
    resources=1000
  fi  
  ;;
  (r999)
    ################################# development variables
    jobscript=control.r999
    jobdir=$controldir
    job_name=
    during_previous_job=no
    job_type=serial
    wall_clock_limit="00:19:00"
#   resources="ConsumableCpus(1) ConsumableMemory(1650 MB)"
    resources="1650M"
  if [[ $gefsmachine = wcoss ]]; then                       
    wall_clock_limit="00:10"
    MP_SHARED_MEMORY=yes
    resources=1000
  fi  
  if [[ $gefsmachine = dell ]]; then                       
    wall_clock_limit="00:10"
    MP_SHARED_MEMORY=yes
    resources=1000
  fi  
  ;;
  (*)
    echo
    echo `date` taskname=$taskname NOT IDENTIFIED
    echo
    echo `date` $0 $* EXIT ABORT 7
    echo
    exit 7
  ;;
esac

echo
echo `date` before prod check during_previous_job=$during_previous_job
#machl=`uname -n | cut -c1`
##DHOU 03/23/2012 fix machl for ZEUS. (for interactive it is f. in batch jobs it will be r)
#machl=f
#prodl=`cat /etc/prod | cut -c1`
echo prodl=$prodl machl=$machl
echo PRODUCTION TEST DISABLED
#if [[ x$prodl = x$machl ]]; then
#  echo we are running on the production machine, so run one job at a time
#  during_previous_job=no
#else
#  echo we are not running on the production machine
#fi
echo `date` after prod check during_previous_job=$during_previous_job

echo
echo `date` $0 $*                                               echo production variables
echo

if [[ -n $cyc_fcst ]]; then
   echo cyc_fcst=$cyc_fcst
fi
if [[ -n $job_name ]]; then
   echo job_name=$job_name
fi
if [[ -n $RUN ]]; then
   echo RUN=$RUN
fi
if [[ -n $FORECAST_SEGMENT ]]; then
   echo FORECAST_SEGMENT=$FORECAST_SEGMENT
fi

if [[ -n $job_type ]]; then
   echo job_type=$job_type
fi
if [[ -n $node_usage ]]; then
   echo node_usage=$node_usage
fi
if [[ -n $tasks_per_node ]]; then
   echo tasks_per_node=$tasks_per_node
fi
if [[ -n $total_tasks ]]; then
   echo total_tasks=$total_tasks
fi
if [[ -n $node ]]; then
   echo node=$node
fi
if [[ -n $wall_clock_limit ]]; then
   echo wall_clock_limit=$wall_clock_limit
fi
if [[ -n $resources ]]; then
   echo resources=$resources
fi
if [[ -n $node_resources ]]; then
   echo node_resources=$node_resources
fi
if [[ -n $task_affinity ]]; then
   echo task_affinity=$task_affinity
fi
if [[ -n $parallel_threads ]]; then
   echo parallel_threads=$parallel_threads
fi
if [[ -n $network_MPI ]]; then
   echo network_MPI=$network_MPI
fi
if [[ -n $MP_SHARED_MEMORY ]]; then
   echo MP_SHARED_MEMORY=$MP_SHARED_MEMORY
fi
if [[ -n $MEMORY_AFFINITY ]]; then
   echo MEMORY_AFFINITY=$MEMORY_AFFINITY
fi
if [[ -n $MP_INFOLEVEL ]]; then
   echo MP_INFOLEVEL=$MP_INFOLEVEL
fi

echo 
echo `date` $0 $*                                         create non-production variables
echo

id=`echo $expid|cut -c3-4`
jobname=$id$PDY$cyc$jjj
out_name=$jobname.$job

if [[ -n $id ]]; then
   echo id=$id
fi

echo
echo `date` $0 $*                                           echo non-production variables
echo

if [[ -n $mem ]]; then
   echo mem=$mem
fi
if [[ -n $taskname ]]; then
   echo taskname=$taskname
fi
if [[ -n $job ]]; then
   echo job=$job
fi
if [[ -n $jobname ]]; then
   echo jobname=$jobname
fi
if [[ -n $out_name ]]; then
   echo out_name=$out_name
fi
if [[ -n $during_previous_job ]]; then
   echo during_previous_job=$during_previous_job
fi
if [[ -n $splim ]]; then
   echo splim=$splim
fi
if [[ $job_type = parallel ]]; then
  class=$classp
  echo class=$class
else
  class=$classs
  echo class=$class
fi

echo 

echo input production variables
echo
echo PDY=$PDY
echo cyc=$cyc
echo envir=$envir
echo
echo input non-production variables
echo 
echo expid=$expid
echo jjj=$jjj
echo
echo output production variables
echo
echo MEMORY_AFFINITY=$MEMORY_AFFINITY
echo MP_INFOLEVEL=$MP_INFOLEVEL
echo MP_SHARED_MEMORY=$MP_SHARED_MEMORY
echo FORECAST_SEGMENT=$FORECAST_SEGMENT
echo RUN=$RUN
echo cyc=$cyc
echo cyc_fcst=$cyc_fcst
echo envir=$envir
echo job_name=$job_name
echo job_type=$job_type
echo network_MPI=$network_MPI
echo node=$node
echo node_resources=$node_resources
echo node_usage=$node_usage
echo tasks_per_node=$tasks_per_node
echo parallel_threads=$parallel_threads
echo resources=$resources
echo task_affinity=$task_affinity
echo total_tasks=$total_tasks
echo wall_clock_limit=$wall_clock_limit
echo
echo output non-production variables
echo
echo during_previous_job=$during_previous_job
echo expid=$expid
echo id=$id
echo job=$job
echo jobname=$jobname
echo mem=$mem
echo out_name=$out_name
echo taskname=$taskname
echo splim=$splim
echo

################################################################## tseqflag section begin

if [[ $tseqflag = yes ]]; then
  echo `date` $0 $* tseqflag test statement inserted here
  echo `date` $0 $* $0 before
  sleep 3
  nohup $0 $yyyymmddccb$jjjb $yyyymmddcce$jjje tseqnext >/dev/null 2>&1 &
  sleep 1 
  echo `date` $0 $* $0 after
else

#################################################################### tseqflag section end

echo
echo `date` $0 $*                                          create directories for any job
echo

d=
plcontrolt=$baseoutput/nw$envir/control/$PDY/$cyc
d="$d $plcontrolt"

plcomout=$baseoutput/com/output/$envir/$PDY
d="$d $plcomout"

pllogdir=$baselog/com/logs
d="$d $pllogdir"

tmpdir=$basetmp
d="$d $tmpdir"

d="$d $basewait"

for dir in $d
do
  if [[ -d $dir ]]; then
    echo dir=$dir already exists
  else
    echo dir=$dir does not already exist
    mkdir -p $dir
    rc=$?
    if (( rc != 0 )); then
      echo mkdir -p $dir FAILED rc=$rc
      echo
      echo `date` $0 $* EXIT ABORT $rc
      echo
      exit $rc
    fi
  fi
  ls -ald $dir
done

echo
echo `date` $0 $*                                        test whether to submit this time
echo

submitnow=no
if [[ $whenrun = before ]] && [[ $during_previous_job = yes ]]; then
  submitnow=yes
fi
if [[ $whenrun = after ]] && [[ $during_previous_job = no ]]; then
  submitnow=yes
fi
if [[ $whenrun = neither ]]; then
  submitnow=yes
fi
echo whenrun=$whenrun during_previous_job=$during_previous_job submitnow=$submitnow

if [[ $submitnow = no ]]; then

  echo `date` $0 $* now is not the time to submit this job
  rc=8

else

  echo
  echo `date` $0 $*                                  create directories for non-wait jobs
  echo

  d=

  plnwges=$baseoutput/nwges/$envir/gefs_legacy.$PDY
  d="$d $plnwges"

  if [[ $gfssource = para ]]; then
    # RLW 20170302 for parallel gfs testing
    basedgfs=/gpfs/hps/ptmp/emc.glopara
    plcomgfs=$basedgfs/com2/gfs/para/gfs.$PDY
    clcomgfs=/com2/gfs/para/gfs.$PDY
    clcomgfs=/gpfs/hps/nco/ops/com/gfs/prod/gfs.$PDY
    clcomgfs=/gpfs/dell1/nco/ops/com/gfs/prod/gfs.$PDY
    clcomgfs=/gpfs/td1/emc/noscrub/Richard.Wobus/o/com/gfs/prod/gfs.$PDY
  else
    plcomgfs=$basedgfs/com2/gfs/prod/gfs.$PDY
    clcomgfs=/com2/gfs/prod/gfs.$PDY
    clcomgfs=/gpfs/hps/nco/ops/com/gfs/prod/gfs.$PDY
    clcomgfs=/gpfs/dell1/nco/ops/com/gfs/prod/gfs.$PDY
    clcomgfs=/gpfs/td1/emc/noscrub/Richard.Wobus/o/com/gfs/prod/gfs.$PDY
  fi
  # RLW 20180907 for parallel gfs testing with FV3
  plcomgfs=$basedgfs/com/gfs/para/gfs.$PDY/$cyc
  # RLW 20190613 for parallel gfs testing with FV3
  plcomgfs=$basedgfs/com/gfs/prod/gfs.$PDY/$cyc

# d="$d $plcomgfs"
#DHOU 01/28/2013, remove this temporally 
  plcomgens=$baseoutput/com/$NET/$envir/gefs_legacy.$PDY
  d="$d $plcomgens"

  for dir in $d
  do
    if [[ -d $dir ]]; then
      echo dir=$dir already exists
    else
      echo dir=$dir does not already exist
      mkdir -p $dir
      rc=$?
      if (( rc != 0 )); then
	echo mkdir -p $dir FAILED rc=$rc
	echo
	echo `date` $0 $* EXIT ABORT $rc
	echo
	exit $rc
      fi
    fi
    ls -ald $dir
  done

  echo
  echo `date` $0 $*                                               check for required data
  echo

  cycle=t${cyc}z

  waitflag=no
  if [[ -s $basewait/waitfile.$machl ]]; then
    waitflag=`tail -1 $basewait/waitfile.$machl`
    echo basewait directory waitfile.$machl file used to set waitflag=$waitflag
  else
    echo basewait directory does not contain the waitfile.$machl file
  fi

  ############### if task is init.separate, then check for gfs analysis
  if [[ $taskname = init.separate ]]; then
    filelist=
    filelist="$filelist gfs.$cycle.sanl"
    filelist="$filelist gfs.$cycle.sfcanl"
    # 20170302 alternate filenames to check for nemsio input
    filelist="$filelist gfs.$cycle.atmanl.nemsio"
    filelist="$filelist gfs.$cycle.sfcanl.nemsio"
    filelist="$filelist gfs.$cycle.syndata.tcvitals.tm00"
    filelist="$filelist avn.$cycle.cyclone.trackatcfunix"
    echo filelist=$filelist
    ifa=0
    iff=0
    for file in $filelist
    do
      ((ifa=ifa+1))
      dirfile=$plcomgfs/$file
      comfile=$clcomgfs/$file
      if [[ -f $dirfile ]]; then
	echo dirfile=$dirfile found
	(( iff = iff + 1 ))
      else
	if [[ -f $comfile ]]; then
	  #cp $comfile $dirfile
	  #rc=$?
	  #if (( rc == 0 )); then
	    ls -al $comfile $dirfile
	    #echo copy succeeded
	    (( iff = iff + 1 ))
	  #else
	    #echo cp $comfile $dirfile FAILED rc=$rc
	    #tflag=yes
	  #fi
	else
	  echo file=$file NOT FOUND
	  if (( ifa == 6 )); then
	    touch $dirfile
	    (( iff = iff + 1 ))
	  fi
	fi
      fi
    done
    if (( iff < 4 )); then
      echo THE NUMBER OF FILES FOUND IS ONLY $iff
      waitflag=yes
    fi
  fi
waitflag=no

  ############## if task is forecast, check for initial conditions begin ################
  ########## copied from later version

    if [[ $taskname = forecast ]]; then

      echo `date` $0 check for initial conditions for taskname=$taskname begin
      if (( cyc == cyc_fcst )); then
	memnum=00
	suffix=
      else
	memnum=01
	suffix=.cycfs$cyc_fcst
      fi
      while (( memnum <= 2 * npair ))
      do
	if (( memnum == 0 )); then
	  mem=c$memnum
	else
	  mem=p$memnum
	fi
	gessig=ge$mem.$cycle.sanl$suffix
	gessfc=ge$mem.$cycle.sfcanl$suffix
	if [[ ! -a $plnwges/$gessig ]]; then
	  echo     $plnwges/$gessig IS MISSING
	  waitflag=yes
	fi
	if [[ ! -a $plnwges/$gessfc ]]; then
	  echo     $plnwges/$gessfc IS MISSING
	  waitflag=yes
	fi
	if [[ ! -a $plcomgens/$cyc/init/$gessig ]]; then
	  echo     $plcomgens/$cyc/init/$gessig IS MISSING
	  waitflag=yes
	fi
	(( memnum = memnum + 1 ))
	if (( memnum < 10 )); then
	  memnum=0$memnum
	fi
      done
      echo `date` $0 check for initial conditions for taskname=$taskname end

      if [[ $cleanbeforefcst = yes ]]; then
	echo `date` $0 clean before forecast begin
	for dir in $plnwges
	do
	  if [[ -d $dir ]]; then
	    cd $dir
	    rc=$rc
	    if (( rc == 0 )); then
	      echo `date` $0 guess list before begin
	      ls -al
	      echo `date` $0 guess list before end
	      for file in ge???.$cycle.sigs?$suffix ge???.$cycle.b???$suffix ge???.$cycle.b????$suffix ge???.$cycle.sf??$suffix ge???.$cycle.sf???$suffix ge???.$cycle.ss??$suffix ge???.$cycle.ss???$suffix
	      do
		if [[ -f $file ]]; then
		  ls -al $file
		  rm -f $file
		  ls -al $file
		fi
	      done
	      echo `date` $0 guess list after begin
	      ls -al
	      echo `date` $0 guess list after end
	    else
	      echo cd $dir FAILED rc=$rc
	    fi
	  fi
	done
	for dir in $plcomgens/$cyc/misc
	do
	  if [[ -d $dir ]]; then
	    cd $dir
	    rc=$rc
	    if (( rc == 0 )); then
	      for file in ge???.$cycle.logf??$suffix ge???.$cycle.logf???$suffix ge???.$cycle.*.control$suffix
	      do
		if [[ -f $file ]]; then
		  ls -al $file
		  rm -f $file
		  ls -al $file
		fi
	      done
	    else
	      echo cd $dir FAILED rc=$rc
	    fi
	  fi
	done
	for dir in $plcomgens/$cyc/sfcsig $plcomgens/$cyc/sflux
	do
	  if [[ -d $dir ]]; then
	    cd $dir
	    rc=$rc
	    if (( rc == 0 )); then
	      for file in ge???.$cycle.*f??$suffix ge???.$cycle.*f???$suffix ge???.$cycle.sigs?$suffix
	      do
		if [[ -f $file ]]; then
		  ls -al $file
		  rm -f $file
		  ls -al $file
		fi
	      done
	    else
	      echo cd $dir FAILED rc=$rc
	    fi
	  fi
	done
	for dir in $plcomgens/$cyc/stats
	do
	  if [[ -d $dir ]]; then
	    cd $dir
	    rc=$rc
	    if (( rc == 0 )); then
	      for file in sigstat.ge???.$cycle.*f??$suffix sigstat.ge???.$cycle.*f???$suffix
	      do
		if [[ -f $file ]]; then
		  ls -al $file
		  rm -f $file
		  ls -al $file
		fi
	      done
	    else
	      echo cd $dir FAILED rc=$rc
	    fi
	  fi
	done
	for dir in $plcomgens/$cyc/pgrb*
	do
	  if [[ -d $dir ]]; then
	    cd $dir
	    rc=$rc
	    if (( rc == 0 )); then
	    for file in ge???.$cycle.*f??$suffix ge???.$cycle.*f???$suffix  ge???.$cycle.*f??.2$suffix ge???.$cycle.*f???.2$suffix ge???.$cycle.*f??$suffix.idx ge???.$cycle.*f???$suffix.idx  ge???.$cycle.*f??.2$suffix.idx ge???.$cycle.*f???.2$suffix.idx ge???.$cycle.*anl$suffix ge???.$cycle.*anl$suffix.idx
	    do
	      if [[ -f $file ]]; then
		ls -al $file
		rm -f $file
		ls -al $file
	      fi
	    done
	    else
	      echo cd $dir FAILED rc=$rc
	    fi
	  fi
	done
	for dir in $tmpdir/gefs_post_ge???_${PDY}_${cyc}_${cyc_fcst}.$envir $tmpdir/gefs_prdgen_ge???_${PDY}_${cyc}_${cyc_fcst}.$envir
	do
	  if [[ -d $dir ]]; then
	    du -ks $dir
	    echo `date` $0 tmp dir $dir list before begin
	    ls -al $dir
	    echo `date` $0 tmp dir $dir list before end
	    rm -rf $dir
	    echo `date` $0 tmp dir $dir list after begin
	    ls -al $dir
	    echo `date` $0 tmp dir $dir list after end
	  fi
	done
	echo `date` $0 clean before forecast end
      else
	echo `date` $0 clean before forecast not requested
      fi

    fi

  ############## if task is forecast, check for initial conditions end ################

  echo
  echo `date` $0 $*                                                       check for space 
  echo

#echo $waitflag =waitflag
#echo $testflag $basebin
#echo DHOUTEST
#exit

  if [[ $testflag = yes ]]; then
    echo DO NOT REALLY CALL $basebin/$space.scrub
    space=500400300200100
    echo FOR TESTING ONLY space=$space 
  else
    space=`$basebin/space.scrub`
  fi
  if (( space < splim )); then
    echo not enough space to run
    echo space=$space does not exceed splim=$splim AND IS NOT ENOUGH TO RUN
    echo WAIT FOR MORE SPACE
    waitflag=yes
  else
    echo space=$space exceeds splim=$splim and is enough to submit the next job
  fi

  echo
  echo `date` $0 $*                                            check for restricted hours
  echo

  if [[ $waitflag = no ]]; then
    # test whether the job about to be submitted is on the list of jobs to be submitted during restricted hours
    rjnfound=no
    for jjtest in $restrictjobjlist
    do
      if [[ $jjj = $jjtest ]]; then
	rjnfound=yes
	echo rjnfound=$rjnfound jjj=$jjj
      fi
    done
    # if it is, test whether the current hour is one of the hours during which these jobs are allowed to run
    if [[ $rjnfound = yes ]]; then
      wcurrent=`date +%w`
      echo wcurrent=$wcurrent
      # test whether the current weekday is one on which job restrictions are imposed
      for wtest in $restrictjobwlist
      do
	if (( wtest == wcurrent )); then
	  waitflag=yes
	  hhcurrent=`date +%H`
	  echo hhcurrent=$hhcurrent
	  for hhtest in $restrictjobhlist
	  do
	    if (( hhcurrent == hhtest )); then
	      waitflag=no
	      echo waitflag=$waitflag jjj=$jjj hhtest=$hhtest
	    fi
	  done
	fi
      done
    fi
  fi

  echo
  echo `date` $0 $*                                                  check for pausecycle
  echo

  if [[ $waitflag = no ]]; then
    if [[ $PDY$cyc = $pausecycle ]]; then
      waitflag=yes
      echo waitflag=$waitflag because pausecycle=$pausecycle matches current cycle $PDY$cyc
    else
      echo pausecycle=$pausecycle does not match current cycle $PDY$cyc
    fi
  fi

  echo
  echo `date` $0 $*                                              check for number of jobs
  echo

  if [[ $machl = r ]]; then                       
       machl=f
  fi
  if [[ $gefsmachine = css ]]; then                       
# Put this block in "if  fi" statement to skip it for ZEUS/WCOSS
  
  jobllq=-9
  jobtotllq=-99
  if [[ $waitflag = no ]]; then
    sleep 10
    llqstring=`$controldir/llqww x nu`
    jobllq=`echo "$llqstring" | grep -c $LOGNAME`
    jobtotllq=`echo "$llqstring" | grep -c " I "`

    if (( jobtotllq > jobtotlim )); then
      echo jobtotllq=$jobtotllq exceeds jobtotlim=$jobtotlim SO WAIT FOR SOME JOBS TO FINISH
      waitflag=yes
    else
      echo jobtotllq=$jobtotllq does not exceed jobtotlim=$jobtotlim so the next job can be submitted
    fi
    case $class in
      (devhigh)
	jobllqdevhigh=`echo $"$llqstring" | grep ' devhigh ' | grep -c $LOGNAME`
	if (( jobllqdevhigh > joblimdevhigh )); then
	  echo jobllqdevhigh=$jobllqdevhigh exceeds joblimdevhigh=$joblimdevhigh SO WAIT FOR SOME JOBS TO FINISH
	  waitflag=yes
	else
	  echo jobllqdevhigh=$jobllqdevhigh does not exceed joblimdevhigh=$joblimdevhigh so the next job can be submitted
	fi
      ;;
      (dev)
	jobllqdev=`echo "$llqstring" | grep -e ' dev ' -e ' devhigh ' | grep -c $LOGNAME`
	if (( jobllqdev > joblimdev )); then
	  echo jobllqdev=$jobllqdev exceeds joblimdev=$joblimdev SO WAIT FOR SOME JOBS TO FINISH
	  waitflag=yes
	else
	  echo jobllqdev=$jobllqdev does not exceed joblimdev=$joblimdev so the next job can be submitted
	fi
      ;;
      (*)
	if (( jobllq > joblim )); then
	  echo jobllq=$jobllq exceeds joblim=$joblim SO WAIT FOR SOME JOBS TO FINISH
	  waitflag=yes
	else
	  echo jobllq=$jobllq does not exceed joblim=$joblim so the next job can be submitted
	fi
      ;;
    esac
    if [[ $during_previous_job = no ]]; then
      jobtest1=$id$PDY$cyc
#DH   pdycycprev=`/nwprod/util/exec/ndate -$fhrp $PDY$cyc`
      pdycycprev=`$NDATE -$fhrp $PDY$cyc`
      jobtest2=$id$pdycycprev
      echo jobtest1=$jobtest1 pdycycprev=$pdycycprev jobtest2=$jobtest2 miwait=$miwait waitflag=$waitflag before
      numcurrent=`echo "$llqstring" | grep -c -e $jobtest1 -e $jobtest2`
      if (( numcurrent > 1 )); then
	waitflag=yes
	miwait=2
      fi
      echo during_previous_job=$during_previous_job numcurrent=$numcurrent miwait=$miwait waitflag=$waitflag after
    fi
  fi

#DHOU  added "if ... fi" to skip the block for ZEUS/WCOSS
  fi
#echo DHOUTEST now
#echo $class $testflag $waitflag
#exit

  ######################## if testing do not wait ########### begin
  if [[ $testflag = yes ]]; then
    if [[ $waitflag = yes ]]; then
      echo
      echo waitflag=$waitflag
      waitflag=no
      echo reset waitflag because testflag=$testflag
      echo waitflag=$waitflag
      echo
    fi
  fi
  ######################## if testing do not wait ########### end

  echo
  echo `date` $0 $*                                     set job variables for run or hold
  echo

  yymmddhhmmss=`date +%y%m%d%H%M%S`

  if [[ $waitflag = no ]]; then
    jobcontrol=$plcontrolt/${jobname}
  else
    jobcontrol=$plcontrolt/${jobname}w
    yyyymmddhhmm=`date +"%Y%m%d%H%M"`
    yyyymmddhh=`echo $yyyymmddhhmm|cut -c1-10`
    mi=`date +"%M"`
    if (( jobtotllq > jobtotlim )); then
      miwait=180
    fi
    echo wait time miwait=$miwait
    (( mi = mi + miwait ))
    while (( mi > 59 ))
    do
      yyyymmddhh=`$NDATE +1 $yyyymmddhh`
      (( mi = mi - 60 ))
    done
    if (( mi < 10 )); then
      mi=0$mi
    fi
    yyyy=`echo $yyyymmddhh|cut -c1-4`
    mo=`echo $yyyymmddhh|cut -c5-6`
    dd=`echo $yyyymmddhh|cut -c7-8`
    hh=`echo $yyyymmddhh|cut -c9-10`
    startdate="${mo}:$dd:${hh}:${mi}"
    echo
    echo startdate=$startdate
    echo
  fi

  echo waitflag=$waitflag
  echo jobcontrol=$jobcontrol

#DHOU, 01/03/2013 slplit the script section of setting up job card to separate files for each particular machine (setupr_job_card.$mach).
echo $cwd

. $cwd/setup_job_card.$gefsmachine

#DHOU 01/03/2013 end of changed section

  echo
  echo `date` job cards begin
  echo
  cat $jobcontrol
  echo 
  echo `date` job cards end
  echo

  cd $plcontrolt
  rc=$?
  if (( rc != 0 )); then
    echo cd plcontrolt=$plcontrolt FAILED rc=$rc
    echo
    echo `date` $0 $* EXIT ABORT $rc
    echo
    exit $rc
  fi

  echo
  echo `date` $0 environment before submit
  echo
  env|sort

  echo
  ls -al $jobcontrol

  ################################################################ tcdsflag section begin

  if [[ $tcdsflag = yes ]]; then
    echo `date` $0 $* tcdsflag test statement inserted here
    echo `date` $0 $* $0 before
    pwd
    cd $nldir
    pwd
    sleep 3
    echo  $0 $yyyymmddccb$jjjb $yyyymmddcce$jjje tcdsnext
    nohup $0 $yyyymmddccb$jjjb $yyyymmddcce$jjje tcdsnext >/dev/null 2>&1 &
    sleep 1 
    echo `date` $0 $* $0 after
  else

  ################################################################## tcdsflag section end

  echo
  echo `date` $0 $*                                                    submit $jobcontrol
  echo
  ####### extra submit test begin #######################################################
  if (( jobllq > jobmax )); then
    echo jobllq=$jobllq exceeds jobmax=$jobmax WHICH IS TOO MANY LL JOBS
    echo
    echo `date` $0 $* EXIT ABORT $jobllq
    echo
    exit $jobllq
  else
    echo jobllq=$jobllq does not exceed jobmax=$jobmax
  fi
  ###### extra submit test end ##########################################################
 echo DHOUTEST
#echo $testflag $machl
 echo $jobcontrol
 echo $job_type
#exit
# llsubmit $jobcontrol

# msub $jobcontrol
  bsub  < $jobcontrol
rc=$?
if (( rc != 0 )); then
  echo llsubmit $jobcontrol FAILED rc=$rc
  if [[ $gefsmachine = ccs ]]; then
    echo `date` $0 $* cat llqstring before
    cat $llqstring
    echo `date` $0 $* cat llqstring after
  fi
  fi

fi

############### from tcdsflag section begin
fi
############### from tcdsflag section end

######## from tseqflag section begin
fi
######## from tseqflag section end

########### from joblist section begin
fi
########### from joblist section end

echo
echo `date` $0 $*                                       end of logged execution of script
echo

) 2>&1 | tee -a $ldir/$lname
echo $ldir
echo RLW 20150316 DISABLED TO PREVENT TIMEOUTSr:"   ls -ablprt $ldir | tail -7"

echo
echo `date` $0 $*                                                                     end
echo

if (( rc != 0 )); then
  echo `date` $0 $* EXIT $rc
fi
exit $rc
